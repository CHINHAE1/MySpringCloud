### commons里面开发工具类

> JWT生成工具类，因为Auth模块还有Gateway都要用JWT工具类。



引入依赖：

```xml
<!-- 提供 Auth和GateWay的全局过滤器使用-->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.18.2</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
```

#### 1.开发JWT工具类

```java
package com.woniuxy.utils;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;

import java.util.Date;

/**
 * @Author: 马宇航
 * @Todo: JWT工具类，生成token，验证token，获得token中的信息无需secret解密也能获得，AI生成工具，百度都有源码
 * @DateTime: 25/04/09/星期三 15:12
 * @Component: 成都蜗牛学苑
 **/
public class JWTUtils {
    //内部定义枚举类
    public enum TokenStatusEnum{
        TOKEN_EXPIRE,
        TOKEN_ERROR,//被人篡改过token
        TOKEN_SUCCESS;
    }
    //统一秘钥定义
    private static final String SECURY_KEY="wonixuy123123";
    //过期时间 正常的jwt的过期时间
    private static final Long TOKEN_EXPIRE_TIME= 10 * 60 * 1000L; //10MIN -->企业中是30min
    //双token的，刷新token 时间会比较长，面试容易被问到的点
    public static final Long REFRESH_TOKEN_EXPIRE_TIME=30 * 60 * 1000L; //30MIN -->企业中 60min
    //加密算法固定
    private static Algorithm algorithm = Algorithm.HMAC256(SECURY_KEY);
    /**
     * 生成token
     * ChangeLog : 1. 创建 (25/01/08/0008 09:51 [马宇航]);
     * @param username  登录成功的用户名
     * @return java.lang.String
     */
    public static String createToken(String username){
        Date now = new Date();
        return JWT.create()
                .withIssuer("mayuhang") //签发人
                .withIssuedAt(now) //签发时间
                .withClaim("username",username) //payload 自定义的用户数据 明文
                .withExpiresAt(new Date(now.getTime() + TOKEN_EXPIRE_TIME)) //过期时间
                .sign(algorithm);
    }
    /**
     * token验证
     * ChangeLog : 1. 创建 (25/01/08/0008 09:57 [马宇航]);
     * @param token
     * @return com.woniuxy.utils.JWTUtils.TokenStatusEnum
     */
    public static TokenStatusEnum verify(String token){
        try {
            JWTVerifier verifier = JWT.require(algorithm)
                    .withIssuer("mayuhang")
                    .build();
            verifier.verify(token);
            return TokenStatusEnum.TOKEN_SUCCESS;
        }catch (TokenExpiredException e){
            //过期异常会在之前先进行校验
            return TokenStatusEnum.TOKEN_EXPIRE;
        }catch (JWTVerificationException e){
            //这个异常 就直接是 token 验证不通过的异常
            return TokenStatusEnum.TOKEN_ERROR;
        }
    }
    /**
     * Description : 获得token中的信息无需secret解密也能获得  <br/>
     * ChangeLog : 1. 创建 (2021/5/3 22:01 [mayuhang]);
     * @param token
     * @return token中包含的用户名
     **/
    public static String getUserName(String token){
        try {
            DecodedJWT jwt = JWT.decode(token);
            return jwt.getClaim("username").asString();
        }catch (JWTDecodeException e){
            return TokenStatusEnum.TOKEN_ERROR.name();
        }
    }
}
```

#### 2.开发redis工具类

```java
package com.woniuxy.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @Author: 马宇航
 * @Todo: redis工具类
 * @DateTime: 25/04/09/星期三 15:35
 * @Component: 成都蜗牛学苑
 **/
@Component
public class RedisUtils {
    @Autowired
    StringRedisTemplate stringRedisTemplate;
    /**
     * 设置键值对
     * @param key 键
     * @param value 值
     */
    public void set(String key, String value) {
        stringRedisTemplate.opsForValue().set(key, value);
    }

    /**
     * 设置带过期时间的键值对
     * @param key 键
     * @param value 值
     * @param timeout 过期时间
     * @param unit 时间单位
     */
    public void set(String key, String value, long timeout, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, value, timeout, unit);
    }

    /**
     * 根据键获取值
     * @param key 键
     * @return 值
     */
    public String get(String key) {
        return stringRedisTemplate.opsForValue().get(key);
    }

    /**
     * 删除键
     * @param key 键
     * @return 是否删除成功
     */
    public boolean delete(String key) {
        return stringRedisTemplate.delete(key);
    }

    /**
     * 判断键是否存在
     * @param key 键
     * @return 是否存在
     */
    public boolean hasKey(String key) {
        return stringRedisTemplate.hasKey(key);
    }

    /**
     * 为键设置过期时间
     * @param key 键
     * @param timeout 过期时间
     * @param unit 时间单位
     * @return 是否设置成功
     */
    public boolean expire(String key, long timeout, TimeUnit unit) {
        return stringRedisTemplate.expire(key, timeout, unit);
    }

    /**
     * 获取键的剩余过期时间
     * @param key 键
     * @param unit 时间单位
     * @return 剩余过期时间
     */
    public Long getExpire(String key, TimeUnit unit) {
        return stringRedisTemplate.getExpire(key, unit);
    }

    /**
     * 设置 Hash 类型的字段值
     * @param key 键
     * @param hashKey Hash 字段
     * @param value 值
     */
    public void hset(String key, String hashKey, String value) {
        stringRedisTemplate.opsForHash().put(key, hashKey, value);
    }

    /**
     * 批量设置 Hash 类型的字段值
     * @param key 键
     * @param map 包含多个 Hash 字段和值的 Map
     */
    public void hsetAll(String key, Map<String, Object> map) {
        stringRedisTemplate.opsForHash().putAll(key, map);
    }

    /**
     * 获取 Hash 类型的字段值
     * @param key 键
     * @param hashKey Hash 字段
     * @return 值
     */
    public String hget(String key, String hashKey) {
        return (String) stringRedisTemplate.opsForHash().get(key, hashKey);
    }

    /**
     * 获取整个 Hash 类型的数据
     * @param key 键
     * @return 包含所有 Hash 字段和值的 Map
     */
    public Map<Object, Object> hgetAll(String key) {
        return stringRedisTemplate.opsForHash().entries(key);
    }

    /**
     * 删除 Hash 类型的字段
     * @param key 键
     * @param hashKeys 要删除的 Hash 字段数组
     * @return 删除的字段数量
     */
    public Long hdel(String key, Object... hashKeys) {
        return stringRedisTemplate.opsForHash().delete(key, hashKeys);
    }

    /**
     * 判断 Hash 类型中是否存在某个字段
     * @param key 键
     * @param hashKey Hash 字段
     * @return 是否存在
     */
    public boolean hHasKey(String key, String hashKey) {
        return stringRedisTemplate.opsForHash().hasKey(key, hashKey);
    }
    //单独给某个键设置过期时间
    public void setExpire(String key, long timeout, TimeUnit unit) {
        stringRedisTemplate.expire(key, timeout, unit);
    }
}
```

### 2. auth模块里面开发登录业务

service和dao自己写，我下面的 代码，不符合逻辑，不要再controller层写业务。

```java
package com.woniuxy.controller;

import com.woniuxy.entity.User;
import com.woniuxy.entity.utils.ResponseMyEntity;
import com.woniuxy.service.AuthService;
import com.woniuxy.utils.JWTUtils;
import com.woniuxy.utils.RedisUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 25/04/09/星期三 15:21
 * @Component: 成都蜗牛学苑
 **/
@RestController
@RequestMapping("/auth")
public class AuthController {
    @Autowired
    AuthService authService;
    @Autowired
    RedisUtils redisUtils;
    @PostMapping("/login")
    public ResponseMyEntity login(@RequestBody User user) {
        //不要直接传账号密码去匹配，通常只传账号
        User account = authService.login(user.getUsername());
        if (account == null) {
            return new ResponseMyEntity(500, "账号或密码错误");
        }else if (account.getPassword().equals(user.getPassword())){
            //token本身的过期时间 30min
            String token = JWTUtils.createToken(account.getUsername());
            //token使用双token，不要把长token返回给前端，因为token并非安全
            //refreshToken自身没有过期效果 所以只能通过redis来控制过期时间 60min
            String refreshToken = UUID.randomUUID().toString();
            /*
                1.用户长时间不操作，30min到60min之间，token过期，但是refreshToken还在，
                2.所以，重新自动生产新的token，而不要用户重新登录
                3.但是用户如果超过了60min，refreshToken过期，用户需要重新登录
                4.所以，refreshToken的过期时间要比token的过期时间长
                5.所以，refreshToken是一个key，token是一个value的一部分

                思考：为什么token的过期时间要设置的很短？
                核心还是安全问题，token不安全。不能让一个token一直存在
             */
            //把token和用户信息，都存起来，key是refreshToken ，用什么类型？
            Map<String, Object> value= new HashMap<>();
            redisUtils.hsetAll(refreshToken, value);
            //给某个key设置过期时间
            redisUtils.expire(refreshToken, 60, TimeUnit.MINUTES);
            return new ResponseMyEntity(refreshToken);
        }else
            return new ResponseMyEntity(500, "账号或密码错误");
    }
}
```

## 四、GateWay中的配置

### 1. yml引入route-->Auth

```yml
- id: myh-auth # 路由id
  uri: lb://myh-auth # 路由地址
  predicates: # 路由条件
    - Path=/auth/**
```

### 2. 开发全局过滤器

所有登录请求，都需要在请求头里面，找Authorization！

```java
package com.woniuxy.config;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * @Author: 马宇航
 * @Todo: 全局过滤器
 * @DateTime: 25/04/09/星期三 16:43
 * @Component: 成都蜗牛学苑
 **/
@Component
public class AuthGlobalFilter implements GlobalFilter,Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("我们的全局过滤器生效！"+exchange.getRequest().getURI());
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

以上代码，已经可以生效了。

> 业务需求，校验token是否存在，以及是否过期。



完整代码如下：

```java
package com.woniuxy.config;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.woniuxy.entity.utils.ResponseMyEntity;
import com.woniuxy.utils.JWTUtils;
import com.woniuxy.utils.RedisUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @Author: 马宇航
 * @Todo: 全局过滤器
 * @DateTime: 25/04/09/星期三 16:43
 * @Component: 成都蜗牛学苑
 **/
@Component
public class AuthGlobalFilter implements GlobalFilter,Ordered {
    @Autowired
    RedisUtils redisUtils;
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("我们的全局过滤器生效！"+exchange.getRequest().getURI());
        //判断是否是登录请求，如果是登录请求，直接放行
        if (exchange.getRequest().getURI().getPath().contains("/auth/login")){
            return chain.filter(exchange);
        }
        //判断是否是注册请求，如果是注册请求，直接放行
        if (exchange.getRequest().getURI().getPath().contains("/auth/register")){
            return chain.filter(exchange);
        }
        //不是上诉请求，就需要校验token
        String refreshToken = exchange.getRequest().getHeaders().getFirst("Authorization");
        //判断是否有refreshToken
        if (redisUtils.hasKey(refreshToken)) {
            //取出里面的内容
            Map<String, Object> content = redisUtils.hgetAll(refreshToken);
            String token = (String) content.get("token");
            //判断token是否过期
            JWTUtils.TokenStatusEnum verify = JWTUtils.verify(token);
            //只有token过期在30min~60min之间，才需要重新生成token
            if (verify == JWTUtils.TokenStatusEnum.TOKEN_EXPIRE) {
                //token过期，但是refreshToken还在，重新生成token
                String newToken = JWTUtils.createToken((String) content.get("account"));
                //更新redis中的token
                content.put("token", newToken);
                //把新的token重新更新进去
                redisUtils.hsetAll(refreshToken, content);
                //给某个key设置过期时间
                redisUtils.expire(refreshToken, 60, TimeUnit.MINUTES);
                //重新更新了 新token后，要放行
                return chain.filter(exchange);
            }
            else if (verify == JWTUtils.TokenStatusEnum.TOKEN_ERROR) {
                //定义一个自定义Flux流式响应的方法
               return returnUnauthorized(exchange);
            } else if (verify == JWTUtils.TokenStatusEnum.TOKEN_SUCCESS) {
                //校验通过业务
                return chain.filter(exchange);
            }else{
                //token 完全不存在
                return returnUnauthorized(exchange);
            }
        }else {
            return returnUnauthorized(exchange);
        }
    }

    private Mono<Void> returnUnauthorized(ServerWebExchange exchange) {
        //获取响应
        ServerHttpResponse response = exchange.getResponse();
        ResponseMyEntity responseMyEntity = new ResponseMyEntity(HttpStatus.UNAUTHORIZED.value(), "token过期");
        //想要在WebFlux返回，不能直接用，用我们的字节流方案，自己处理自定义响应类型
        try {
            //转换为字节流
            byte[] bytes = new ObjectMapper().writeValueAsBytes(responseMyEntity);
            DataBuffer wrap = response.bufferFactory().wrap(bytes);
            //响应Mono方案
            return response.writeWith(Mono.just(wrap));
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

## 五、commons中开发权限注解

> 因为所有模块的controller都要用到权限注解。操作权限。Perm   role  user 三个表 RBAC概念。
>
> 通常redis里面存储的数据，是会包含用户的角色权限信息。
>
> 开发一个自定义注解，



```java
package com.woniuxy.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @Author: 马宇航
 * @Description: 自定义权限注解
 * @DateTime: 25/04/09/星期三 17:33
 * @Component: 成都蜗牛学苑
 **/
//表示，该注解，可以加到方法上和类上
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME) //运行时生效
public @interface PermAccess {
    //权限的标记字段 order::add
    String value() default "";
}
```

上诉代码要生效，需要用到一个拦截器。

```java
package com.woniuxy.interceptor;

import com.woniuxy.anno.PermAccess;
import org.hibernate.bytecode.enhance.spi.interceptor.AbstractInterceptor;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.lang.reflect.Method;

/**
 * @Author: 马宇航
 * @Todo: TODO
 * @DateTime: 25/04/09/星期三 17:36
 * @Component: 成都蜗牛学苑
 **/
public class PermInterceptor extends HandlerInterceptorAdapter {
    /**
     * 进入controller之前有效果
     * ChangeLog : 1. 创建 (25/04/09/星期三 17:37 [马宇航]);
     * @param request
     * @param response
     * @param handler controller对象，目标进入的controller对象，
     * @return boolean true就会放行
    */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(handler);
        //直接获取方法上的注解
        if (handler instanceof HandlerMethod) {
            Method method = ((HandlerMethod) handler).getMethod();
            //判断方法上是否有PermAccess注解
            if (method.isAnnotationPresent(PermAccess.class)) {
                //如果存在，则进行值的获取，来校验，用户权限和注解配置的权限是否匹配
                PermAccess permAccess = method.getAnnotation(PermAccess.class);
                String value = permAccess.value();
                //"order::add" 是写死的，但是实际上，是根据refreshToken去redis中获取 用户的信息，拿到用户的权限列表
                if(value.equals("order::add")){
                    System.out.println("权限校验通过");
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * controller执行之后有效果
     * ChangeLog : 1. 创建 (25/04/09/星期三 17:37 [马宇航]);
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @return void
    */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        super.afterCompletion(request, response, handler, ex);
    }
}
```

配置类：

```java
package com.woniuxy.interceptor;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @Author: 马宇航
 * @Todo: 拦截器配置类
 * @DateTime: 25/04/09/星期三 17:40
 * @Component: 成都蜗牛学苑
 **/
@Configuration
public class SpringMVCInterceptorConfiguration implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new PermInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/login")
                .order(1); //拦截器的执行顺序
    }
}
```

上述代码，都是在commons中开发的，就会导致GateWay因为这个拦截器配置，无法启动，大家解决下这个问题。